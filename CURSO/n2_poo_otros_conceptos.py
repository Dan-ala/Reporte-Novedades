# -*- coding: utf-8 -*-
"""N2_POO otros conceptos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ETilW7pzdWEuSGou--E1TWTR4uFbUrwe

![M I S I Ó N.png](data:image/png;base64,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)

# Conceptos POO aplicados en Python

Ya hemos abordado algunos de los principales conceptos de la POO en Python como **Clases**, **Objetos**, **Asociación**, **Agregación**, **Composición**, **Herencia**, **Atributos y Métodos de instancia y de clase**, **Métodos estáticos**, **Modificadores de acceso**, etc.  


A continuación profundizaremos en otros conceptos importantes asociados a la POO y aplicados en Python

## Encapsulación

Ya anteriormente vimos cómo declarar los atributos de una clase privados __atributo_privado.  

El objetivo de la encapsulación es ocultar la complejidad interna de un objeto y exponer solamente una interfaz pública que permita interactuar con él.  En términos prácticos sería poner los atributos privados (para que no puedan ser accedidos o modificados directamente) y los métodos públicos que accedan o modifiquen el estado del objeto.  

**¿Ventajas de la encapsulación?**

Miremos un ejemplo de una clase **sin** encapsulación y **con** encapsulación
"""

#Ejemplo sin encapsulación
class Persona:
    def __init__(self, nombre, edad):
        self.nombre = nombre
        self.edad = edad
######################################

p = Persona ("Juan",-30)
print (f"{p.nombre} tiene {p.edad} años")

"""Cuando permitimos que se pueda acceder directamente a los atributos de una clase, no existe manera de protegerla para evitar el acceso o modificación incorrecta de su estado.   """

#Ejemplo con encapsulación
class Persona:
    def __init__(self, nombre, edad):
        self.set_nombre(nombre)
        self.set_edad(edad)

    def get_nombre(self):
        return self.__nombre

    def set_nombre(self, nombre):
        self.__nombre = nombre

    def get_edad(self):
        return self.__edad

    def set_edad(self, edad):
        self.__edad = edad

p = Persona ("Juan",-30)
#print (f"{p.nombre} tiene {p.edad} años") #esta línea genera error, no podemos acceder a los atributos directamente
print (f"{p.get_nombre()} tiene {p.get_edad()} años") #Solo podemos acceder a los atributos a través de los métodos públicos

"""**Controlando el acceso a los atributos privados desde los métodos públicos**"""

class Persona:
    def __init__(self, nombre, edad):
        self.set_nombre(nombre)
        self.set_edad(edad)

    def get_nombre(self):
        return self.__nombre

    def set_nombre(self, nombre):
        self.__nombre = nombre

    def get_edad(self):
          return self.__edad

    def set_edad(self, edad):
        try:
            if edad >= 0:
                self.__edad = edad
            else:
                raise ValueError("La edad no puede ser negativa")
        except Exception as e:
            self.__edad = None
            print(e)
######################################################################3
p = Persona ("Juan",90)
print (f"{p.get_nombre()} tiene {p.get_edad()} años")

"""**Ejemplo de Python implementando la encapsulación en sus propias clases**"""

lista = [] #Se define un objeto de tipo List vacío
#lista[0] = "hola" #error al intentar establecer un valor directamente
lista.insert(0,"hola")                   #cómo solucionarlo?
print(lista[0])

"""## Sobrecarga de métodos y constructores

La sobrecarga hace referencia a la capacidad de tener el mismo método definido más de una vez en una clase pero con diferentes cantidades o tipos de parámetros.  En lenguajes como Java, la sobrecarga es un concepto ampliamente aplicable por las características del lenguaje.  Un ejemplo en Java de sobrecarga de constructores es el siguiente:


```
public Persona(){}
public Persona(String nombre){}
public Persona(String nombre, int edad){}
public Persona(String nombre, int edad, String direccion){}
```
Esto permitiría crear objetos de la clase Persona de diferentes maneras.


"""

p1 = new Persona ()
p1 = new Persona ("Juan")
p1 = new Persona ("Juan",30)
p1 = new Persona ("Juan",30, "calle 3")

class Persona:
    def __init__(self, nombre):
        self.nombre = nombre

    def __init__(self, nombre, edad):
        self.nombre = nombre
        self.edad = edad

    def salude(self):
        print("Hola")

    def salude(self, nombre):
        print(f"Bueno(a)s {nombre}")
##################################################################
#p1 = Persona("juan") #genera error
p2 = Persona("pedro", 20)
p2.salude() #genera error
p2.salude("dias")

"""**¿Porqué Python no usa la sobrecarga?**




"""

class Persona:
    def __init__(self, nombre="NN", edad=None):
        self.nombre = nombre
        self.edad = edad

    def salude(self, nombre=None):
        if nombre is not None:
          print (f"bueno(a)s {nombre}")
        else:
          print("Hola")

##################################################################
po = Persona()
p1 = Persona("juan")
p2 = Persona("pedro", 20)
p2.salude()
p2.salude("noches")

"""**Termina la siguiente clase llamada Operaciones en Python para que los llamados a los métodos sumar de las líneas 4, 5, 6 y 7 funcionen correctamente:**"""

class Operaciones:
   @staticmethod
   def sumar(*args):
    return sum(args)


###############################
print (Operaciones.sumar(3, 4))
print (Operaciones.sumar(4.5, 3.2))
print (Operaciones.sumar(3 ,4, 8, 10, 12))
print (Operaciones.sumar(2.5 ,4, 8.2, 5, 3.5,4,5,6,7,5,3,3,4,5,54,3,34))
print (Operaciones.sumar(3,2,43))



"""Como puedes ver, el dinamismo y la flexibilidad del lenguaje Python hace que no sea necesaria la sobrecarga.

**Un paso más alla...**

¿Qué pasa si como programador no tengo idea de los atributos que se quieran definir en tiempo de ejecución para una clase?
"""

class Persona:
  def __init__(self, **kwargs):
      for k in kwargs:
          setattr(self, k, kwargs[k])

  def mostrar_informacion(self):
      print(vars(self))
 ############################################

p1 = Persona(nombre="Julian Valencia")
p1.mostrar_informacion()


p2 = Persona(nombre="Claudia Perez", edad=27)
p2.mostrar_informacion()

p3 = Persona(nombre="Ricardo Luna", edad=30, correo="rluna@gmail.com")
p3.mostrar_informacion()

"""## Sobreescritura

Se refiere a la capacidad de una subclase de modificar o extender el comportamiento de un método definido en una superclase.

Es decir, si una clase hija tiene un método con el mismo nombre y parámetros que uno definido en la clase padre, entonces el método de la clase hija sobrescribe al método de la clase padre.
"""

class Animal:
    def hacer_sonido(self):
        print("Un animal está haciendo un sonido")

class Perro(Animal):
    def hacer_sonido(self):
        print("El perro está ladrando")
####################################################
animal = Animal()
animal.hacer_sonido()  # salida: "Un animal está haciendo un sonido"

perro = Perro()
perro.hacer_sonido()  # salida: "El perro está ladrando"

"""## Polimorfismo


Es la capacidad de objetos de diferentes clases de responder a la misma función o método de manera diferente.

Existen diferentes clases de polimorfismos, veamos algunos ejemplos:

**Polimorfismo con métodos**  es quizás el tipo de polimorfismo más reconocido y consiste en la forma en la que dos diferentes objetos responden de manera diferente ante la invocación del mismo método.
"""

#Ejemplo Polimorfismo con métodos
class Animal:
    def __init__(self, nombre):
        self.nombre = nombre

    def hablar(self):
        pass

class Perro(Animal):
    def hablar(self):
        return "guau"

class Gato(Animal):
    def hablar(self):
        return "miau"
######################################################
animales = [Perro("Firulays"), Gato("Tom")]

for animal in animales:
    print(animal.nombre + ": " + animal.hablar())

"""**Polimorfismo con funciones** es la capacidad que tienen las funciones de adaptar su comportamiento para responder de manera diferente ante la invocación con diferentes parámetros"""

#Ejemplo Polimorfismo con funciones
def suma(a, b):
    return a + b

print(suma(2, 3))   # Salida: 5
print(suma("Hola", " Mundo"))   # Salida: "Hola Mundo"
print(suma(5.6, 2.5))   # Salida: 8.1
print (suma([3, 2],[4, 9]))  #Salida: [3, 2, 4, 9]

"""**Polimorfismo paramétrico**  Hace referencia a la capacidad que tiene un método de adaptar su comportamiento de acuerdo con el objeto que recibe como parámetro, sin necesidad de escribir un método diferente para cada tipo de objeto."""

#Ejemplo polimorfismo paramétrico
class Animal:
    def hacer_sonido(self):
        pass

class Perro(Animal):
    def hacer_sonido(self):
        print("¡guau!")

class Gato(Animal):
    def hacer_sonido(self):
        print("¡miau!")

class Burro(Animal):
    def hacer_sonido(self):
        print("¡grugruhghghgh!")

#########################################
def hacer_sonido_animal(animal):
    if isinstance(animal, Animal):
        animal.hacer_sonido()
    else:
        print("Este objeto no es un animal")
##################################################
perro = Perro()
gato = Gato()
burro = Burro()
otro_objeto = object()

hacer_sonido_animal(perro)   # Salida: ¡guau!
hacer_sonido_animal(gato)# Salida: ¡miau!
hacer_sonido_animal(burro)
hacer_sonido_animal(otro_objeto) # Salida: Este objeto no es un animal

"""## Cohesión

La cohesión es el grado en que los miembros de una clase (atributos y métodos) se relacionan entre sí y trabajan armónicamente para lograr el resultado definido.

En POO se recomienda que las clases tengan una alta cohesión.  Miremos un ejemplo de alta y baja cohesión usando la clase Cuenta
"""

#Clase Cuenta con baja cohesión:
class Cuenta:
  def __init__(self, saldo, cliente, ciudad):
    self.saldo = saldo
    self.cliente = cliente
    self.ciudad = ciudad

  def calcular_impuesto(self):
    if isinstance(self, Ahorro):
      impuesto = self.saldo *0.05
    else:
      impuesto = self.saldo *0.07
    return impuesto

#Clase Cuenta con alta cohesión:
class Cuenta:
  def __init__(self, interes=0.03, saldo=0):
    self.saldo = saldo
    self.interes = interes

  def depositar(self, monto):
    self.saldo += monto

  def retirar(self, monto):
    if self.saldo-monto >=0:
      self.saldo -= monto

  def consultar(self):
    return self.saldo

  def aplicar_interes(self):
    saldo = saldo + (saldo*self.interes)

  def retornar_interes(self):
    return self.interes

"""## Acoplamiento

El acoplamiento en POO se refiere al nivel de dependencia entre las clases.  De esta manera, un alto acoplamiento significa que los cambios en una clase repercuten en otra.  

En POO se recomienda tener bajo acoplamiento, de esta manera, las clases  están menos interconectadas y son más independientes. Esto puede hacer que el sistema sea más fácil de mantener y modificar.
"""

#Ejemplo Alto Acoplamiento
class Persona:
    def __init__(self, nombre, edad):
        self.nombre = nombre
        self.edad = edad

    def saludar(self):
        print(f"Hola, mi nombre es {self.nombre} y tengo {self.edad} años.")

class Empleado:
    def __init__(self, nombre, edad, salario):
        self.persona = Persona(nombre, edad) #esto crea alto acoplamiento
        self.salario = salario

    def presentarse(self):
        self.persona.saludar()
        print(f"Soy un empleado y mi salario es {self.salario}")
################################################################
e = Empleado("Juan", 30, 1200)
e.presentarse()
e.persona.saludar()

#Ejemplo Bajo Acoplamiento
class Persona:
    def __init__(self, nombre, edad):
        self.nombre = nombre
        self.edad = edad

    def saludar(self):
        print(f"Hola, mi nombre es {self.nombre} y tengo {self.edad} años.")

class Empleado:
    def __init__(self, persona, salario):
        self.persona = persona #bajo acoplamiento
        self.salario = salario

    def presentarse(self):
        self.persona.saludar()
        print(f"Soy un empleado y mi salario es {self.salario}")
###############################################################
p = Persona("Carlos", 45)
e = Empleado(p, 1200)
e.presentarse()
p.saludar()

"""## Clases Abstractas

Una clase abstracta es una clase que no se pueden instanciar directamente y que definen métodos concretos (con código) o abstractos (métodos sin código en su cuerpo).  Estas clases abstractas son creadas para ser heredadas por otras clases concretas cuya obligación es implementar los métodos abstractos heredados.  

**Sintaxis:**

Para definir una clase abstracta en Python se debe importar el módulo **abc** que significa **Abstract Base Classes** este módulo cuenta con una clase **ABC** de ka cual debe heredar cualquier clase abstracta.



```
from abc import ABC
class MiClaseAbstracta(ABC):
```
Los métodos abstractos dentro de una clase abstracta deben llevar el decorador @abstractmethod

```
from abc import ABC, abstractmethod

class MiClaseAbstracta(ABC):

    @abstractmethod
    def metodo_abstracto(self):
        pass
```

"""

from abc import ABC, abstractmethod
class Persona(ABC):

  @abstractmethod
  def saludo(self):
    pass
########################################
p = Persona()

from abc import ABC, abstractmethod
class Figura(ABC):

  def mensaje (self):
    print ("Hola, soy una figura geométrica")

  @abstractmethod
  def calcular_area(self):
    pass
#######################################
class Cuadrado(Figura):
  def __init__(self, lado):
    self.lado = lado

  def calcular_area(self):   #implementando el método abstracto heredado
    return self.lado*self.lado
########################################

class Triangulo(Figura):
  def __init__(self, base, altura):
    self.base = base
    self.altura = altura

  def calcular_area(self):   #implementando el método abstracto heredado
    return (self.base * self.altura) / 2
########################################

c = Cuadrado(5)
c.mensaje()   #se hereda el método concreto
print("el area del cuadrado es: ",c.calcular_area())

t = Triangulo (5,3)
t.mensaje()
print("El area del triangulo es:",t.calcular_area())

"""## Interfaces

En Python no existe una palabra reservada para definir una interfaz.  Una iterfaz en Python es una clase abstracta donde todos sus métodos son abstractos.  Al tener una interfaz, la clase concreta que hereda de ella está obligada a implementar todos los métodos definidos en la interfaz.  
"""

from abc import ABC, abstractmethod
class Humano (ABC):
  @abstractmethod
  def respirar(self):
    pass

  @abstractmethod
  def comer(self):
    pass

  @abstractmethod
  def dormir(self):
    pass

class Estudiante(Humano):
  pass

est1 = Estudiante()

"""# Apropiación

1. Cree una clase llamada "CuentaBancaria" que tenga atributos privados para el número de cuenta, el titular de la cuenta y el saldo. Cree métodos para depositar, retirar y transferir dinero entre cuentas. Asegúrese de que no se puedan modificar ni el número de cuenta ni el titular de la cuenta una vez creada la instancia de la clase. Además, que el saldo nunca sea negativo y que las transferencias solo puedan realizarse entre cuentas de la misma moneda.
"""



"""2.  Cree una clase llamada Figura y tres subclases llamadas Circulo, cuadrado y Triangulo.  Realice una implementación de las clases consistentes con el nombre de cada una y sobreescriba el método **calcular_area()** en cada subclase para que el resultado sea el correcto de acuerdo con su nombre. Compruebe el funcionamiento de las diferentes clases."""



"""3. Cree una Interface llamada Juego con los métodos abstractos iniciar, mostrar_puntaje, terminar.  Cree un juego sencillo que implemente la interfaz Juego y compruebe el funcionamiento del mismo."""

